use std::fmt::{Display, Formatter, Result as FmtResult};
use std::collections::{HashMap, HashSet};

use crate::token::{TokenType};
use crate::token::{Literal as LexLiteral};
use crate::ast::{Arg as AstArg, *};
use crate::error::Error;

#[derive(Clone, Debug, PartialEq)]
pub enum Value {
    Address(usize),
    Number(f64),
    String(String),
    Bool(bool),
    Nil,
}

impl Value {
    pub fn truthy(&self) -> bool {
        match self {
            Value::Number(n) => *n != 0.0,
            Value::String(s) => s.len() > 0,
            Value::Bool(b) => *b,
            Value::Nil | Value::Address(_) => false,
            // An Address should never be generated by the user. Always Falsey is the simplest way to
            // represent that.
        }
    }
    
    pub fn is_num(&self) -> bool {
        if let Value::Number(_) = self {true} else {false}
    }

    pub fn is_str(&self) -> bool {
        if let Value::String(_) = self {true} else {false}
    }
}

impl Display for Value {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        match self {
            Value::Address(a) => write!(f, "*{}", a),
            Value::Number(n) => write!(f, "{}", n),
            Value::String(s) => write!(f, "{}", s),
            Value::Bool(b) => write!(f, "{}", b),
            Value::Nil => write!(f, "nil"),
        }
    }
}

impl std::str::FromStr for Value {
    type Err = Error;
    fn from_str(value: &str) -> Result<Value, Error> {
        if value.as_bytes()[0] == b'"' {
            Ok(Value::String(value.to_string()))
        } else if value.as_bytes()[0].is_ascii_digit() {
            value.parse().map(|n| Value::Number(n)).map_err(|_| Error::IRParse {
                line: 0,
                msg: "Invalid word, expected number".into(),
            })
        } else if value == "true" || value == "false" {
            Ok(Value::Bool(value == "true"))
        } else if value == "nil" {
            Ok(Value::Nil)
        } else {
            Err(Error::IRParse {
                line: 0,
                msg: format!("Unrecognized value: '{}'", value),
            })
        }
    }
}

pub enum Op {
    // Use(String),

    Load(usize), // relative index of the variable on the stack
    Store(usize),
    Get(String),
    Set(String),
    Push(Value),
    Pop,
    Dup,

    Add,
    Sub,
    Mul,
    Div,
    Mod,
    Exp,
    Neg,
    Abs,

    And,
    Or,
    Not,
    Xor,

    Eq,
    Ne,
    Lt,
    Le,
    Gt,
    Ge,

    Jump(usize), // absolute position
    JumpUnless(usize),
    JumpIf(usize),

    Label(String),
    Call(String),
    CallParallel(String),
    CallRace(String),
    End,
    Return,
}

impl Display for Op {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        use Op::*;
        match self {
            // Use(s) => write!(f, "use \"{}\"", s),
            Load(a) => write!(f, "load {}", a),
            Store(a) => write!(f, "store {}", a),
            Get(s) => write!(f, "get \"{}\"", s),
            Set(s) => write!(f, "get \"{}\"", s),
            Push(v) => write!(f, "push {}", v),
            Jump(a) => write!(f, "jump {}", a),
            JumpUnless(a) => write!(f, "jump_unless {}", a),
            JumpIf(a) => write!(f, "jump_if {}", a),
            Label(s) => write!(f, "{}:", s),
            Call(s) => write!(f, "call \"{}\"", s),
            CallParallel(s) => write!(f, "call_parallel \"{}\"", s),
            CallRace(s) => write!(f, "call_race \"{}\"", s),
            End => write!(f, "end"),
            Return => write!(f, "return"),
            Pop => write!(f, "pop"),
            Dup => write!(f, "dup"),
            Add => write!(f, "add"),
            Sub => write!(f, "sub"),
            Mul => write!(f, "mul"),
            Div => write!(f, "div"),
            Mod => write!(f, "mod"),
            Exp => write!(f, "exp"),
            Neg => write!(f, "neg"),
            Abs => write!(f, "abs"),
            And => write!(f, "and"),
            Or => write!(f, "or"),
            Not => write!(f, "not"),
            Xor => write!(f, "xor"),
            Eq => write!(f, "eq"),
            Ne => write!(f, "ne"),
            Lt => write!(f, "lt"),
            Le => write!(f, "le"),
            Gt => write!(f, "gt"),
            Ge => write!(f, "ge"),
        }
    }
}

impl std::str::FromStr for Op {
    type Err = Error;
    fn from_str(value: &str) -> Result<Op, Error> {
        let parts = value.split(" ").collect::<Vec<&str>>();
        match parts[0] {
            // "use" => if parts[1].as_bytes()[0] != b'"' {
            //     Err(Error::IRParse{line: 0, msg: "'use' must take a string".into()})
            // } else if !parts[1][1..].contains("\"") {
            //     Err(Error::IRParse{line: 0, msg: "Unterminated string in 'use'".into()})
            // } else {
            //     Ok(Op::Use(parts[1][1..parts[1].len()-1].into()))
            // }
            "load" => parts[1].parse().map(|a| Op::Load(a)).map_err(|_| Error::IRParse {
                line: 0,
                msg: format!("Invalid stack address: '{}'", parts[1]),
            }),
            "store" => parts[1].parse().map(|a| Op::Store(a)).map_err(|_| Error::IRParse {
                line: 0,
                msg: format!("Invalid stack address: '{}'", parts[1]),
            }),
            "get" => if parts[1].as_bytes()[0] != b'"' {
                Err(Error::IRParse{line: 0, msg: "'get' must take a string".into()})
            } else if !parts[1][1..].contains("\"") {
                Err(Error::IRParse{line: 0, msg: "Unterminated string in 'get'".into()})
            } else {
                Ok(Op::Get(parts[1][1..parts[1].len()-1].into()))
            }
            "set" => if parts[1].as_bytes()[0] != b'"' {
                Err(Error::IRParse{line: 0, msg: "'set' must take a string".into()})
            } else if !parts[1][1..].contains("\"") {
                Err(Error::IRParse{line: 0, msg: "Unterminated string in 'set'".into()})
            } else {
                Ok(Op::Set(parts[1][1..parts[1].len()-1].into()))
            }
            "push" => parts[1].parse().map(|v| Op::Push(v)),
            "jump" => parts[1].parse().map(|a| Op::Jump(a)).map_err(|_| Error::IRParse {
                line: 0,
                msg: format!("Invalid stack address: '{}'", parts[1]),
            }),
            "jump_unless" => parts[1].parse().map(|a| Op::JumpUnless(a)).map_err(|_| Error::IRParse {
                line: 0,
                msg: format!("Invalid stack address: '{}'", parts[1]),
            }),
            "jump_if" => parts[1].parse().map(|a| Op::JumpIf(a)).map_err(|_| Error::IRParse {
                line: 0,
                msg: format!("Invalid stack address: '{}'", parts[1]),
            }),
            "call" => if parts[1].as_bytes()[0] != b'"' {
                Err(Error::IRParse{line: 0, msg: "'call' must take a string".into()})
            } else if !parts[1][1..].contains("\"") {
                Err(Error::IRParse{line: 0, msg: "Unterminated string in 'call'".into()})
            } else {
                Ok(Op::Call(parts[1][1..parts[1].len()-1].into()))
            }
            "call_parallel" => if parts[1].as_bytes()[0] != b'"' {
                Err(Error::IRParse{line: 0, msg: "'call_parallel' must take a string".into()})
            } else if !parts[1][1..].contains("\"") {
                Err(Error::IRParse{line: 0, msg: "Unterminated string in 'call_parallel'".into()})
            } else {
                Ok(Op::CallParallel(parts[1][1..parts[1].len()-1].into()))
            }
            "call_race" => if parts[1].as_bytes()[0] != b'"' {
                Err(Error::IRParse{line: 0, msg: "'call_race' must take a string".into()})
            } else if !parts[1][1..].contains("\"") {
                Err(Error::IRParse{line: 0, msg: "Unterminated string in 'call_race'".into()})
            } else {
                Ok(Op::CallRace(parts[1][1..parts[1].len()-1].into()))
            }
            "end" => Ok(Op::End),
            "return" => Ok(Op::Return),
            "pop" => Ok(Op::Pop),
            "dup" => Ok(Op::Dup),
            "add" => Ok(Op::Add),
            "sub" => Ok(Op::Sub),
            "mul" => Ok(Op::Mul),
            "div" => Ok(Op::Div),
            "mod" => Ok(Op::Mod),
            "exp" => Ok(Op::Exp),
            "neg" => Ok(Op::Neg),
            "abs" => Ok(Op::Abs),
            "and" => Ok(Op::And),
            "or" => Ok(Op::Or),
            "not" => Ok(Op::Not),
            "xor" => Ok(Op::Xor),
            "eq" => Ok(Op::Eq),
            "ne" => Ok(Op::Ne),
            "lt" => Ok(Op::Lt),
            "le" => Ok(Op::Le),
            "gt" => Ok(Op::Gt),
            "ge" => Ok(Op::Ge),
            _ => {
                if parts[0].ends_with(":") {
                    Ok(Op::Label(parts[0][..parts[0].len()-1].to_string()))
                } else{
                    Err(Error::IRParse {
                        line: 0, // This will need to be backpatched.
                        msg: format!("Invalid op: '{}'", parts[0])
                    })
                }
            }
        }
    }
}

pub trait Callable {
    fn call(&mut self) -> bool;
    fn check_syntax(&self, args: Vec<Arg>) -> Result<(), Error>;
}


pub trait Prop {
    fn get(&self) -> Value;
    fn set(&mut self, val: Value);
    fn settable(&self) -> bool;
}

#[derive(Debug, PartialEq, Clone)]
pub enum Arg {
    Word(String),
    Value,
}

impl Arg {
    pub fn is_value(&self) -> bool {
        if let Arg::Value = self {
            true
        } else {
            false
        }
    }

    pub fn get_word(&self) -> Option<&str> {
        if let Arg::Word(s) = self {
            Some(&s)
        } else {
            None
        }
    }
}

impl Display for Arg {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        match self {
            Arg::Word(s) => write!(f, "'{}'", s),
            Arg::Value => write!(f, "a value"),
        }
    }
}

#[derive(Clone)]
struct CompiledGroup {
    name: String,
    kind: GroupKind,
    address: usize,
    params: Vec<Arg>,
}

impl Callable for CompiledGroup {
    fn call(&mut self) -> bool {
        panic!("This type only exists for the compiler. 'call' should never be called.")
    }
    fn check_syntax(&self, args: Vec<Arg>) -> Result<(), Error> {
        if args.len() != self.params.len() {
            return Err(Error::Call(format!("Call to '{}' expected {} arguments but got {}", 
                                            self.name, 
                                            self.params.len(), 
                                            args.len())));
        }
        for (i, (param, args)) in self.params.iter().zip(args.iter()).enumerate() {
            if param != args {
                return Err(Error::Call(format!("Argument at position {} should be {}", i, param)));
            }
        } 

        Ok(())
    }
}

pub struct Program {
    pub code: Vec<Op>,
    pub callables: HashMap<String, Box<dyn Callable>>,
    pub props: HashMap<String, Box<dyn Prop>>,
}

pub struct Compiler {
    groups: HashMap<String, CompiledGroup>,
    instructions: Vec<Op>,
    callables: HashMap<String, Box<dyn Callable>>,
    properties: HashMap<String, Box<dyn Prop>>,
    allowed_props: HashSet<String>,

    variables: Vec<HashMap<String, usize>>,
    errors: Vec<Error>,
}

impl<'a> Compiler {
    pub fn new() -> Compiler {
        Compiler {
            groups: HashMap::new(),
            instructions: Vec::new(),
            callables: HashMap::new(),
            properties: HashMap::new(),
            allowed_props: HashSet::new(),
            variables: vec![HashMap::new()],
            errors: Vec::new(),
        }
    }

    pub fn compile(mut self, ast: Vec<Stmt<'a>>) -> Result<Program, Vec<Error>> {
        let (groups, program): (Vec<Stmt<'a>>, _) = ast.into_iter().partition(|stmt| {
            if let Stmt::Group(_) = stmt {true} else {false}
        });
      
        let (uses, program): (Vec<Stmt<'a>>, _) = program.into_iter().partition(|stmt| {
            if let Stmt::Use(_) = stmt {true} else {false}
        });

        for us in uses {
            us.accept_mut(&mut self);
        }

        let group_code = self.isolate(move |this| {
            for group in groups.iter() {
                group.accept_mut(this);
            }
        });
        
        self.instructions.push(Op::Jump(self.current_ip() + group_code.len() + 1));
        self.instructions.extend(group_code);
        
        for inst in program.iter() {
            inst.accept_mut(&mut self);
        }


        if self.errors.is_empty() {
            Ok(Program {
                code: self.instructions,
                callables: self.callables,
                props: self.properties,
            })
        } else {
            Err(self.errors)
        }
    }

    pub fn register_callable(&mut self, name: &str, callable: Box<dyn Callable>) -> Result<(), Error> {
        if self.callables.contains_key(name) {
            return Err(Error::DuplicateCallable(name.into()));
        }
        self.callables.insert(name.to_string(), callable);
        Ok(())
    }

    pub fn register_property(&mut self, name: &str, prop: Box<dyn Prop>) -> Result<(), Error> {
        if self.properties.contains_key(name) {
            return Err(Error::DuplicateProperty(name.into()));
        }
        self.properties.insert(name.to_string(), prop);
        Ok(())
    }

    fn declare_var(&mut self, name: &'a str) -> usize {
        let scope = unsafe {self.variables.last_mut().unwrap_unchecked()};
        if scope.contains_key(name) {
            return scope[name];
        }
        let idx = scope.len();
        scope.insert(name.to_string(), idx);
        idx
    }

    fn begin_scope(&mut self) {
        self.variables.push(HashMap::new());
    }

    fn end_scope(&mut self) {
        self.variables.pop();
    }

    fn get_var(&mut self, name: &'a str) -> Result<usize, Error> {
        let scope = unsafe {self.variables.last_mut().unwrap_unchecked()};
        scope.get(name).map(|i| *i).ok_or(Error::Compile{line: 0, msg: format!("Variable '{}' used before it was declared", name)})
    }

    // FIXME if useful, change output to Result<_> Halting parsing may be useful?
    fn isolate<F: FnMut(&mut Self)>(&mut self, mut f: F) -> Vec<Op> {
        let current_program = std::mem::take(&mut self.instructions);
        f(self);
        let sub_program = std::mem::replace(&mut self.instructions, current_program);
        sub_program
    }

    fn current_ip(&self) -> usize {
        self.instructions.len()
    }
}

impl<'a> ExprVisitorMut<'a, ()> for Compiler {
    fn visit_variable_expr(&mut self, expr: &Variable<'a>) {
        let LexLiteral::Ident(name) = expr.name.literal.unwrap() else {
            self.errors.push(Error::Compile{line: 0, msg: "Variable was somehow called without an associated identifier".into()});
            return;
        };

        if self.properties.contains_key(name) {
            if !self.allowed_props.contains(name) {
                self.errors.push(Error::UndeclaredProperty(name.into()));
                return;
            }
            self.instructions.push(Op::Get(name.to_string()));
            return;
        }

        let idx = match self.get_var(name) {
            Ok(idx) => idx,
            Err(e) => {
                self.errors.push(e);
                return;
            }
        };
        self.instructions.push(Op::Load(idx));
    }
    
    fn visit_literal_expr(&mut self, expr: &Literal<'a>) {
        let value = match expr.value {
            LexLiteral::String(s) => Value::String(s.into()),
            LexLiteral::Number(n) => Value::Number(n),
            LexLiteral::Bool(b) => Value::Bool(b),
            LexLiteral::Nil => Value::Nil,
            LexLiteral::Ident(_) => panic!("You are actually using literal identifiers, stupid!"),
        };

        self.instructions.push(Op::Push(value))
    }
    
    fn visit_grouping_expr(&mut self, expr: &Grouping<'a>) {
        expr.expression.accept_mut(self);
        if expr.abs {
            self.instructions.push(Op::Abs);
        }
    }

    fn visit_unary_expr(&mut self, expr: &Unary<'a>) {
        expr.right.accept_mut(self);
        match expr.op.ty {
            TokenType::Not => self.instructions.push(Op::Not),
            TokenType::Minus => self.instructions.push(Op::Neg),
            _ => self.errors.push(Error::Compile{line: 0, msg: "Invalid unary operator".into()}),
        }
    }

    fn visit_binary_expr(&mut self, expr: &Binary<'a>) {
        expr.left.accept_mut(self);
        expr.right.accept_mut(self);

        match expr.op.ty {
            TokenType::BangEqual => self.instructions.push(Op::Ne),
            TokenType::EqualEqual => self.instructions.push(Op::Eq),
            TokenType::Greater => self.instructions.push(Op::Gt),
            TokenType::GreaterEqual => self.instructions.push(Op::Ge),
            TokenType::Less => self.instructions.push(Op::Lt),
            TokenType::LessEqual => self.instructions.push(Op::Le),
            TokenType::Minus => self.instructions.push(Op::Sub),
            TokenType::Plus => self.instructions.push(Op::Add),
            TokenType::Slash => self.instructions.push(Op::Div),
            TokenType::Star => self.instructions.push(Op::Mul),
            TokenType::Percent => self.instructions.push(Op::Mod),
            TokenType::Caret => self.instructions.push(Op::Exp),
            _ => self.errors.push(Error::Compile{line: 0, msg: "Invalid binary operator".into()}),
        }
    }

    // binary_expr!('a, or, xor, logical, [Or]);
    // binary_expr!('a, and, equality, logical, [And]);
    fn visit_logical_expr(&mut self, expr: &Logical<'a>) {
        expr.left.accept_mut(self);
        self.instructions.push(Op::Dup);

        match expr.op.ty {
            TokenType::And => {
                let sub_program = self.isolate(|this| {
                    expr.right.accept_mut(this);
                });
                self.instructions.push(Op::JumpUnless(self.current_ip() + sub_program.len() + 1));
                self.instructions.extend(sub_program);
                self.instructions.push(Op::And);
            }
            TokenType::Or => {
                let sub_program = self.isolate(|this| {
                    expr.left.accept_mut(this);
                });
                self.instructions.push(Op::JumpIf(self.current_ip() + sub_program.len() + 1));
                self.instructions.extend(sub_program);
                self.instructions.push(Op::Or);
            }
            TokenType::Xor => {
                expr.right.accept_mut(self);
                self.instructions.push(Op::Xor);
            }
            _ => {
                self.errors.push(Error::Compile{line: 0, msg: "Invalid logical operator".into()})
            }
        }
    }
}

impl<'a> StmtVisitorMut<'a, ()> for Compiler {
    fn visit_var_stmt(&mut self, stmt: &Var<'a>) {
        stmt.value.accept_mut(self);
        let LexLiteral::Ident(name) = stmt.name.literal.unwrap() else {
            self.errors.push(Error::Compile{line: 0, msg: "Invalid variable name".into()});
            return;
        };

        if let Some(prop) = self.properties.get(name) {
            if !prop.settable() {
                self.errors.push(Error::Compile{line: 0, msg: format!("External property '{}' not settable", name)});
                return;
            }
            self.instructions.push(Op::Set(name.into()));
        } else {
            let idx = self.declare_var(name);
            self.instructions.push(Op::Store(idx));
        }
    }

    fn visit_use_stmt(&mut self, stmt: &Use<'a>) {
        let LexLiteral::Ident(name) = stmt.name.literal.unwrap() else {
            self.errors.push(Error::Compile{line: 0, msg: "'use' statements must only use identifiers".into()});
            return;
        };

        if !self.properties.contains_key(name) {
            self.errors.push(Error::UnknownProperty(name.into()));
            return;
        }

        self.allowed_props.insert(name.into());
    }

    fn visit_exec_stmt(&mut self, stmt: &Exec<'a>) {
        let name = stmt.name.lexeme;

        if !self.groups.contains_key(name) && !self.callables.contains_key(name) {
            self.errors.push(Error::UnknownCallable(name.into()));
            return;
        } 

        let arg_kinds = stmt.args.iter().map(|a| {
            match a {
                AstArg::Word(w) => Arg::Word(w.lexeme.into()),
                AstArg::Value(_) => Arg::Value,
            }
        }).collect();

        if let Some(callable) = self.groups.get(name) {
            if let Err(e) = callable.check_syntax(arg_kinds) {
                self.errors.push(e);
                return;
            }
        } else {
            if let Err(e) = self.callables[name].check_syntax(arg_kinds) {
                self.errors.push(e);
                return;
            }
        }


        for arg in stmt.args.iter() {
            if let AstArg::Value(v) = arg {
                v.accept_mut(self);
            }
        }

        if let Some(group) = self.groups.get(name) {
            match group.kind {
                GroupKind::Parallel => self.instructions.push(Op::CallParallel(name.into())),
                GroupKind::Race => self.instructions.push(Op::CallRace(name.into())),
                GroupKind::Sequence => self.instructions.push(Op::Call(name.into()))
            }
        } else {
            self.instructions.push(Op::Call(name.into()))
        }
    }

    fn visit_group_stmt(&mut self, stmt: &Group<'a>) {
        // TODO 
        // - Disallow recursion
        // - Disallow state statements in non-sequential groups
        self.begin_scope();

        let params: Vec<_> = stmt.params.iter().map(|t| {
            match t.ty {
                TokenType::Word => Arg::Word(t.lexeme.to_string()),
                TokenType::Ident => {
                    let LexLiteral::Ident(name) = t.literal.unwrap() else {unreachable!()};
                    self.declare_var(name);
                    Arg::Value
                }
                _ => unreachable!(),
            }
        }).collect();
        
        let body = self.isolate(|this| {
            this.instructions.push(Op::Label(stmt.name.lexeme.to_string()));
            for stmt in stmt.statements.iter() {
                stmt.accept_mut(this);
            }
            this.instructions.push(Op::End);
            for _ in 0..params.len() {
                this.instructions.push(Op::Pop);
            }
            this.instructions.push(Op::Return);
        });

        let name = stmt.name.lexeme.to_string();
        let group = CompiledGroup {
            name: name.clone(),
            kind: stmt.kind,
            params,
            address: self.current_ip(),
        };
        self.instructions.extend(body);

        if self.callables.contains_key(&name) {
            self.errors.push(Error::DuplicateCallable(name));
        } else {
            self.groups.insert(stmt.name.lexeme.to_string(), group.clone());
        }
        // if let Err(e) = self.register_callable(stmt.name.lexeme, Box::new(group)) {
        //     self.errors.push(e);
        // }
        self.end_scope();
    }

    fn visit_if_stmt(&mut self, stmt: &If<'a>) {
        stmt.condition.accept_mut(self);
        if stmt.invert {
            self.instructions.push(Op::Not);
        }
        let then_branch = self.isolate(|this| {
            for then in stmt.then_branch.iter() {
                then.accept_mut(this);
            }
        });

        let else_branch = self.isolate(|this| {
            for els in stmt.else_branch.iter() {
                els.accept_mut(this);
            }
        });
        let then_len = then_branch.len();
        let else_len = else_branch.len();

        self.instructions.push(Op::JumpUnless(self.current_ip() + then_len + 1));
        self.instructions.extend(then_branch);
        self.instructions.push(Op::Jump(self.current_ip() + else_len + 1));
    }

    fn visit_while_stmt(&mut self, stmt: &While<'a>) {
        let start = self.current_ip();
        stmt.condition.accept_mut(self);
        if stmt.invert {
            self.instructions.push(Op::Not);
        }
        let body = self.isolate(|this| {
            for line in stmt.body.iter() {
                line.accept_mut(this)
            }
            this.instructions.push(Op::Jump(start));
        });

        self.instructions.push(Op::JumpUnless(self.current_ip() + body.len() + 1));
        self.instructions.extend(body);
    }
}
